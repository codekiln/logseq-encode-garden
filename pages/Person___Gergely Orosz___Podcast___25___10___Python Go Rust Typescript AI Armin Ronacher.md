tags:: [[Person/Armin Ronacher]]

- # [Python, Go, Rust, TypeScript and AI with Armin Ronacher](https://newsletter.pragmaticengineer.com/p/python-go-rust-typescript-and-ai)
	- On how Armin uses AI tools ([at 28:05](https://youtu.be/45kVol96IlM?si=qsueCtgWRQ6nAgNj&t=1685)) and how he switched from Terraform to Pulumi
		- > “Over the years, many of my projects didn’t go anywhere because the legwork needed to build this bespoke tooling to be able to pull this project off was too much.
		  **One of the big changes I’m noticing for myself is that I have so many better tools around now.** For example, I moved from [[Terraform]] to [[Pulumi]] for one of the services just to see how that goes. I had Claude build me a perfect control system to get my logs and visualize what’s going on in production. I would never have done this before [Claude Code] just because it wouldn’t have worked.” - #Quote from [[Person/Armin Ronacher]]
	- Why Armin doesn’t believe strongly typed languages like [[Typescript]] meaningfully reduce errors — based on his experience observing this at [[Sentry]] ([at 52:42](https://youtu.be/45kVol96IlM?si=dCLf_qqIjk3rL3cf&t=3174):)
		- > "There was a large-scale realization in JavaScript ecosystem that type checkers could get rid of a whole class of errors, because at the very least you have to explicitly check if this thing is nullable or not.
		  **I never got the feeling that the adoption of TypeScript dramatically changed anything about JavaScript error rates.** None of that adoption had any meaningful impact. If there was an impact, it’s immeasurable.
		  I remember that the adoption of more and more complex things in the React ecosystem has just dramatically increased the types of errors. For example, hydration errors were not a thing for many years. And then all of sudden, there’s a whole class of new errors coming in because of this [because of the wider adoption of React.]" - #Quote from [[Person/Armin Ronacher]]
	- Choose languages pragmatically for the product and team, not ideology; even modern Java can be great with virtual threads as part of a practical stack [pragmatic language choice](https://readwise.io/bookreview/55521719/?highlight=946265317).
	- Python remains unavoidable for ML, data, and infra, though it’s grown in complexity; Go is often easier for high‑throughput services today [state of the Python ecosystem](https://readwise.io/bookreview/55521719/?highlight=946267809).
	- [[Rust]]
		- Rust shines as a pragmatic way to extend Python and for binary/WebAssembly work where memory layout and single‑binary trade‑offs matter [Rust’s pragmatism for extensions](https://readwise.io/bookreview/55521719/?highlight=946268151).
		- For early‑stage startups, Rust’s precision adds friction (compile times, strict types, borrow checker); Go often hits the speed/iteration sweet spot [why Rust can slow startup iteration](https://readwise.io/bookreview/55521719/?highlight=946265288).
	- AI changes language trade‑offs: thin abstractions help agents; measured runs showed #Go codegen passing more often than #Python or #Rust [thin abstractions help AI produce better code](https://readwise.io/bookreview/55521719/?highlight=946270832).
	- Expect #Python and #TypeScript to appear somewhere in your stack regardless; the question is how much of your code lives in them [plan for languages you can’t avoid](https://readwise.io/bookreview/55521719/?highlight=946265389).
	- #TypeScript on the backend is hampered by the NPM ecosystem’s heavy dependency sprawl, which can undermine control and confidence [TypeScript drawbacks on the server](https://readwise.io/bookreview/55521719/?highlight=946268225).
	- Prefer modern codegen and OpenAPI‑driven SDKs over forcing a single language across front‑ and back‑end boundaries [use codegen over a unified codebase](https://readwise.io/bookreview/55521719/?highlight=946268789).
	- AI coding tools now handle boilerplate and “run‑of‑the‑mill” tasks (endpoints, OpenAPI), freeing engineers to focus on authentic, core code—and even enabling quick bespoke tools you’d never have built before [how AI coding tools boost productivity](https://readwise.io/bookreview/55521719/?highlight=946269844).
	- Agents are powerful but can feel like a slot machine—addictive and unsustainable if you’re always “kicking it off again” [the slot‑machine effect of agent chains](https://readwise.io/bookreview/55521719/?highlight=946271947).
	- Good error reporting is a deliberate practice; languages/runtimes should carry richer production context, and context‑locals are crucial when async/await breaks stack‑based propagation [errors need richer production context](https://readwise.io/bookreview/55521719/?highlight=946273821).
	- As systems and teams scale, language adoption is a trade‑off game; sometimes you introduce a new language for performance or ecosystem fit, not purity [language adoption trade‑offs at scale](https://readwise.io/bookreview/55521719/?highlight=946267728).